#!/usr/bin/env node
// Generated by CoffeeScript 1.12.5
var HttpStream, cleanHost, error, http, port, proxy, ref, stream, upstream, urllib,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

http = require('http');

stream = require('stream');

urllib = require('url');

exports.HttpStream = HttpStream = (function(superClass) {
  extend(HttpStream, superClass);

  function HttpStream(options) {
    this.format = bind(this.format, this);
    HttpStream.__super__.constructor.apply(this, arguments);
    this.prefix = options.prefix || '';
    this.buffer = '';
    this.on('pipe', this.headers);
  }

  HttpStream.prototype.headers = function(request) {
    var header, ref, value;
    ref = request.headers;
    for (header in ref) {
      value = ref[header];
      this.write(header + ": " + value + "\n");
    }
    return this.write('\n');
  };

  HttpStream.prototype.format = function(line) {
    return "" + this.prefix + line + "\n";
  };

  HttpStream.prototype._transform = function(chunk, encoding, done) {
    var i, lines, ref;
    this.buffer += chunk.toString(encoding === 'buffer' ? null : encoding);
    if (this.buffer.indexOf('\n') > -1) {
      ref = this.buffer.split('\n'), lines = 2 <= ref.length ? slice.call(ref, 0, i = ref.length - 1) : (i = 0, []), this.buffer = ref[i++];
      this.push(lines.map(this.format).join(''));
    }
    return done();
  };

  HttpStream.prototype._flush = function(done) {
    if (this.buffer) {
      this.push(this.format(this.buffer));
    }
    return done();
  };

  return HttpStream;

})(stream.Transform);

exports.proxy = proxy = function(host) {
  var client, ref;
  host = urllib.parse(cleanHost(host));
  if ((ref = host.protocol) !== 'http:' && ref !== 'https:') {
    throw new Error('httptrail only supports http');
  }
  client = host.protocol === 'https:' ? require('https') : http;
  return http.createServer(function(request, response) {
    var log, proxied, url;
    log = {
      request: new HttpStream({
        prefix: '> '
      }),
      response: new HttpStream({
        prefix: '< '
      })
    };
    log.request.pipe(process.stdout);
    log.response.pipe(process.stdout);
    request.headers.host = host.hostname;
    url = urllib.parse(request.url);
    proxied = client.request({
      hostname: host.hostname,
      port: host.port,
      method: request.method,
      path: url.path,
      auth: url.auth,
      headers: request.headers
    });
    request.pipe(proxied);
    request.pipe(log.request);
    return proxied.once('response', function(upstream) {
      response.writeHead(upstream.statusCode, upstream.headers);
      upstream.pipe(response);
      return upstream.pipe(log.response);
    });
  });
};

cleanHost = function(host) {
  var hostname, port, protocol, ref;
  host = host.trim();
  if (/^\d+$/.test(host)) {
    host = "http://localhost:" + host + "/";
  } else if (!/:\/\//.test(host)) {
    host = host.replace(/^(\/\/)?/, 'http://');
  }
  ref = urllib.parse(host), protocol = ref.protocol, hostname = ref.hostname, port = ref.port;
  protocol || (protocol = 'http:');
  hostname || (hostname = 'localhost');
  port = port ? ":" + port : '';
  return protocol + "//" + hostname + port + "/";
};

if (require.main === module) {
  ref = process.argv.slice(2), upstream = ref[0], port = ref[1];
  if (upstream && port) {
    try {
      upstream = cleanHost(upstream);
      proxy(upstream).listen(port);
    } catch (error1) {
      error = error1;
      process.stderr.write(error + "\n");
      process.exit(1);
    }
    process.stderr.write("Proxying port " + port + " to upstream server at " + upstream + "\n");
  } else {
    process.stderr.write('Usage: httptrail <upstream host> <proxy port>\n');
    process.exit(1);
  }
}
