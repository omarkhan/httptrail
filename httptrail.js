#!/usr/bin/env node
// Generated by CoffeeScript 1.8.0
var HttpStream, cleanHost, error, http, port, proxy, stream, upstream, urllib, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

http = require('http');

stream = require('stream');

urllib = require('url');

exports.HttpStream = HttpStream = (function(_super) {
  __extends(HttpStream, _super);

  function HttpStream(options) {
    this.format = __bind(this.format, this);
    HttpStream.__super__.constructor.apply(this, arguments);
    this.prefix = options.prefix || '';
    this.buffer = '';
    this.on('pipe', this.headers);
  }

  HttpStream.prototype.headers = function(request) {
    var header, value, _ref;
    _ref = request.headers;
    for (header in _ref) {
      value = _ref[header];
      this.write("" + header + ": " + value + "\n");
    }
    return this.write('\n');
  };

  HttpStream.prototype.format = function(line) {
    return "" + this.prefix + line + "\n";
  };

  HttpStream.prototype._transform = function(chunk, encoding, done) {
    var lines, _i, _ref;
    this.buffer += chunk.toString(encoding === 'buffer' ? null : encoding);
    if (this.buffer.indexOf('\n') > -1) {
      _ref = this.buffer.split('\n'), lines = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), this.buffer = _ref[_i++];
      this.push(lines.map(this.format).join(''));
    }
    return done();
  };

  HttpStream.prototype._flush = function(done) {
    if (this.buffer) {
      this.push(this.format(this.buffer));
    }
    return done();
  };

  return HttpStream;

})(stream.Transform);

exports.proxy = proxy = function(host) {
  var client, _ref;
  host = urllib.parse(cleanHost(host));
  if ((_ref = host.protocol) !== 'http:' && _ref !== 'https:') {
    throw new Error('httptrail only supports http');
  }
  client = host.protocol === 'https:' ? require('https') : http;
  return http.createServer(function(request, response) {
    var log, proxied, url;
    log = {
      request: new HttpStream({
        prefix: '> '
      }),
      response: new HttpStream({
        prefix: '< '
      })
    };
    log.request.pipe(process.stdout);
    log.response.pipe(process.stdout);
    url = urllib.parse(request.url);
    proxied = client.request({
      hostname: host.hostname,
      port: host.port,
      method: request.method,
      path: url.path,
      auth: url.auth,
      headers: request.headers
    });
    request.pipe(proxied);
    request.pipe(log.request);
    return proxied.once('response', function(upstream) {
      response.writeHead(upstream.statusCode, upstream.headers);
      upstream.pipe(response);
      return upstream.pipe(log.response);
    });
  });
};

cleanHost = function(host) {
  var hostname, port, protocol, _ref;
  host = host.trim();
  if (/^\d+$/.test(host)) {
    host = "http://localhost:" + host + "/";
  } else if (!/:\/\//.test(host)) {
    host = host.replace(/^(\/\/)?/, 'http://');
  }
  _ref = urllib.parse(host), protocol = _ref.protocol, hostname = _ref.hostname, port = _ref.port;
  protocol || (protocol = 'http:');
  hostname || (hostname = 'localhost');
  port || (port = 8000);
  return "" + protocol + "//" + hostname + ":" + port + "/";
};

if (require.main === module) {
  _ref = process.argv.slice(2), upstream = _ref[0], port = _ref[1];
  if (upstream && port) {
    try {
      upstream = cleanHost(upstream);
      proxy(upstream).listen(port);
    } catch (_error) {
      error = _error;
      process.stderr.write("" + error + "\n");
      process.exit(1);
    }
    process.stderr.write("Proxying port " + port + " to upstream server at " + upstream + "\n");
  } else {
    process.stderr.write('Usage: httptrail <upstream host> <proxy port>\n');
    process.exit(1);
  }
}
