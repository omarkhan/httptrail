#!/usr/bin/env node
// Generated by CoffeeScript 1.8.0
var HttpStream, http, port, proxy, stream, upstream, urllib, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

http = require('http');

stream = require('stream');

urllib = require('url');

exports.HttpStream = HttpStream = (function(_super) {
  __extends(HttpStream, _super);

  function HttpStream(options) {
    this.format = __bind(this.format, this);
    HttpStream.__super__.constructor.apply(this, arguments);
    this.prefix = options.prefix || '';
    this.buffer = '';
    this.on('pipe', this.headers);
  }

  HttpStream.prototype.headers = function(request) {
    var header, value, _ref;
    _ref = request.headers;
    for (header in _ref) {
      value = _ref[header];
      this.write("" + header + ": " + value + "\n");
    }
    return this.write('\n');
  };

  HttpStream.prototype.format = function(line) {
    return "" + this.prefix + line + "\n";
  };

  HttpStream.prototype._transform = function(chunk, encoding, done) {
    var lines, _i, _ref;
    this.buffer += chunk.toString(encoding === 'buffer' ? null : encoding);
    if (this.buffer.indexOf('\n') > -1) {
      _ref = this.buffer.split('\n'), lines = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), this.buffer = _ref[_i++];
      this.push(lines.map(this.format).join(''));
    }
    return done();
  };

  HttpStream.prototype._flush = function(done) {
    if (this.buffer) {
      this.push(this.format(this.buffer));
    }
    return done();
  };

  return HttpStream;

})(stream.Transform);

exports.proxy = proxy = function(port) {
  return http.createServer(function(request, response) {
    var log, proxied, url;
    log = {
      request: new HttpStream({
        prefix: '> '
      }),
      response: new HttpStream({
        prefix: '< '
      })
    };
    log.request.pipe(process.stdout);
    log.response.pipe(process.stdout);
    url = urllib.parse(request.url);
    proxied = http.request({
      port: port,
      method: request.method,
      path: url.path,
      auth: url.auth,
      headers: request.headers
    });
    request.pipe(proxied);
    request.pipe(log.request);
    return proxied.once('response', function(upstream) {
      response.writeHead(upstream.statusCode, upstream.headers);
      upstream.pipe(response);
      return upstream.pipe(log.response);
    });
  });
};

if (require.main === module) {
  _ref = process.argv.slice(2), upstream = _ref[0], port = _ref[1];
  if (upstream && port) {
    process.stderr.write("Proxying port " + port + " to upstream server on port " + upstream + "\n");
    proxy(upstream).listen(port);
  } else {
    process.stderr.write("Usage: " + process.argv[1] + " <upstream port> <proxy port>\n");
    process.exit(1);
  }
}
